name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'

jobs:
  ci-cd:
    name: CI/CD Pipeline
    runs-on: windows-latest
    permissions:
      actions: read
      contents: write
      security-events: write
    
    steps:
    # ============================================
    # Setup
    # ============================================
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          **/packages.lock.json
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/packages.lock.json') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Cache build outputs
      uses: actions/cache@v4
      with:
        path: |
          **/bin
          **/obj
        key: ${{ runner.os }}-build-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-build-

    - name: Restore dependencies
      run: dotnet restore

    # ============================================
    # Code Security Scans (Fail Fast)
    # ============================================
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: csharp
        queries: security-and-quality

    - name: Autobuild for CodeQL
      uses: github/codeql-action/autobuild@v3

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3
      with:
        category: "/language:csharp"

    - name: Build with security analyzers
      run: |
        Write-Host "Building with security analysis enabled..."
        Write-Host "=========================================="
        
        # Build and capture security-related warnings
        $buildOutput = dotnet build --configuration Release --verbosity normal 2>&1 | Out-String
        
        # Check for security-related analyzer warnings (CA5xxx series are security rules)
        $securityWarnings = $buildOutput | Select-String -Pattern "warning CA(53|54|55|56|57|58|59|60|61|62|63|64|65|66|67|68|69|70|71|72|73|74|75|76|77|78|79|80|81|82|83|84|85|86|87|88|89|90|91|92|93|94|95|96|97|98|99|00|01|02|03|04|05)\d+"
        
        if ($securityWarnings) {
          Write-Host "::warning::Security-related code analysis warnings found:"
          $securityWarnings | ForEach-Object { Write-Host $_ }
          Write-Host "These should be reviewed for potential security issues."
        } else {
          Write-Host "‚úì No security-related code analysis warnings"
        }
        
        # Check build succeeded
        if ($LASTEXITCODE -ne 0) {
          Write-Host "::error::Build failed"
          exit 1
        }

    # ============================================
    # Dependency Security Checks (Fail Fast)
    # ============================================
    - name: Check for outdated packages
      id: outdated_check
      run: |
        Write-Host "Checking for outdated NuGet packages..."
        Write-Host "=========================================="
        
        # Only check top-level packages (direct dependencies)
        $outdated = dotnet list package --outdated
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Error checking for outdated packages"
          exit 1
        }
        
        $outdatedOutput = $outdated | Out-String
        Write-Host $outdatedOutput
        
        # Framework/system packages that are managed by .NET runtime
        $frameworkPackages = @(
          "Microsoft.NETCore.Platforms",
          "Microsoft.NETCore.Targets",
          "NETStandard.Library",
          "System.Configuration.ConfigurationManager",
          "System.Diagnostics.DiagnosticSource",
          "System.Diagnostics.EventLog",
          "System.Reflection.Metadata",
          "System.Security.Cryptography.Cng",
          "System.Security.Cryptography.OpenSsl",
          "System.Security.Cryptography.ProtectedData",
          "Microsoft.CodeCoverage",
          "Microsoft.TestPlatform.ObjectModel",
          "Microsoft.TestPlatform.TestHost",
          "NuGet.Frameworks"
        )
        
        # Parse outdated packages (only top-level)
        $outdatedPackages = @()
        $lines = $outdated -split "`n"
        $inTopLevelSection = $false
        
        foreach ($line in $lines) {
          if ($line -match "Top-level Package") {
            $inTopLevelSection = $true
            continue
          }
          if ($line -match "Transitive Package") {
            $inTopLevelSection = $false
            continue
          }
          if ($inTopLevelSection -and $line -match "> (.+?)\s+(\S+)\s+(\S+)") {
            $packageName = $matches[1].Trim()
            $currentVersion = $matches[2].Trim()
            $latestVersion = $matches[3].Trim()
            
            # Skip framework packages managed by .NET
            if ($frameworkPackages -notcontains $packageName) {
              $outdatedPackages += [PSCustomObject]@{
                Package = $packageName
                Current = $currentVersion
                Latest = $latestVersion
              }
            }
          }
        }
        
        if ($outdatedPackages.Count -gt 0) {
          Write-Host "`n::warning::Found $($outdatedPackages.Count) outdated direct package(s):"
          Write-Host "`n| Package | Current Version | Latest Version |"
          Write-Host "|---------|----------------|----------------|"
          foreach ($pkg in $outdatedPackages) {
            Write-Host "| $($pkg.Package) | $($pkg.Current) | $($pkg.Latest) |"
          }
          
          # Check for major version updates in direct dependencies only
          $majorUpdates = $outdatedPackages | Where-Object {
            $currentMajor = ($_.Current -split '\.')[0]
            $latestMajor = ($_.Latest -split '\.')[0]
            $currentMajor -ne $latestMajor
          }
          
          if ($majorUpdates.Count -gt 0) {
            Write-Host "`n::error::Found $($majorUpdates.Count) direct package(s) with major version updates available:"
            foreach ($pkg in $majorUpdates) {
              Write-Host "  - $($pkg.Package): $($pkg.Current) -> $($pkg.Latest)"
            }
            echo "has_major_updates=true" >> $env:GITHUB_OUTPUT
            Write-Host "::error::Major version updates detected. Please review and update packages."
            exit 1
          } else {
            echo "has_major_updates=false" >> $env:GITHUB_OUTPUT
          }
          
          echo "has_outdated=true" >> $env:GITHUB_OUTPUT
          echo "outdated_count=$($outdatedPackages.Count)" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "‚úì All direct packages are up-to-date"
          Write-Host "Note: Transitive and framework packages are managed by .NET runtime"
          echo "has_outdated=false" >> $env:GITHUB_OUTPUT
          echo "has_major_updates=false" >> $env:GITHUB_OUTPUT
          echo "outdated_count=0" >> $env:GITHUB_OUTPUT
        }

    - name: Check for vulnerable packages
      id: vuln_check
      run: |
        Write-Host "Scanning for vulnerable NuGet packages..."
        Write-Host "=========================================="
        $vulnerable = dotnet list package --vulnerable --include-transitive
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Error checking vulnerabilities"
          exit 1
        }
        
        $vulnOutput = $vulnerable | Out-String
        Write-Host $vulnOutput
        
        # Check if any vulnerabilities found
        if ($vulnOutput -match "vulnerable") {
          Write-Host "::error::Vulnerable packages detected!"
          exit 1
        } else {
          Write-Host "‚úì No vulnerable packages found"
        }

    - name: Run OWASP Dependency Check
      uses: dependency-check/Dependency-Check_Action@main
      with:
        project: 'ClaudeCodeInstaller'
        path: '.'
        format: 'HTML'
        args: >
          --enableRetired
          --enableExperimental
          --failOnCVSS 7
      continue-on-error: true

    - name: Upload vulnerability report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: vulnerability-report
        path: reports/*.html
        retention-days: 7

    # ============================================
    # Build
    # ============================================
    - name: Build solution
      run: dotnet build --configuration Release --no-restore

    - name: Publish WinForms Installer
      run: |
        dotnet publish src/ClaudeCodeInstaller.WinForms/ClaudeCodeInstaller.WinForms.csproj `
          --configuration Release `
          --runtime win-x64 `
          --self-contained true `
          --output ./artifacts/winforms `
          /p:PublishSingleFile=true

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: windows-installers
        path: |
          artifacts/**/*.exe
        retention-days: 30

    # ============================================
    # Tests
    # ============================================
    - name: Run tests
      run: dotnet test --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage"

    - name: Upload coverage reports
      uses: codecov/codecov-action@v4
      with:
        files: '**/coverage.cobertura.xml'
        fail_ci_if_error: false

    # ============================================
    # Virus Scan
    # ============================================
    - name: Update Windows Defender definitions
      run: |
        Write-Host "Updating Windows Defender definitions..."
        Update-MpSignature
        Write-Host "‚úì Definitions updated"

    - name: Scan executables with Windows Defender
      run: |
        Write-Host "Scanning executables for viruses and malware..."
        
        # Check if Windows Defender is available
        if (-not (Get-Command Get-MpComputerStatus -ErrorAction SilentlyContinue)) {
          Write-Host "::warning::Windows Defender not available, skipping virus scan"
          Write-Host "This is expected on some GitHub Actions runners"
          exit 0
        }
        
        # Find executables - artifacts are downloaded to current directory
        Write-Host "Looking for executables..."
        Write-Host "Current directory: $(Get-Location)"
        
        # Search recursively from current directory
        $exeFiles = Get-ChildItem -Recurse -Filter *.exe -ErrorAction SilentlyContinue
        
        if ($exeFiles.Count -eq 0) {
          Write-Host "No executables found. Listing directory structure:"
          Get-ChildItem -Recurse -Directory | Select-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
          Write-Host "All files:"
          Get-ChildItem -Recurse -File | Select-Object FullName | ForEach-Object { Write-Host "  $($_.FullName)" }
          Write-Host "::error::No executables found to scan"
          exit 1
        }
        
        Write-Host "Found $($exeFiles.Count) executable(s) to scan"
        
        $scanResults = @()
        $hasThreats = $false
        
        foreach ($file in $exeFiles) {
          Write-Host "Scanning: $($file.Name) ($([math]::Round($file.Length/1MB, 2)) MB)"
          
          try {
            # Perform quick scan on the file
            $scanResult = Start-MpScan -ScanType QuickScan -ScanPath $file.FullName -ErrorAction Stop
            
            # Wait a moment for scan to complete
            Start-Sleep -Seconds 2
            
            # Check for threats detected
            $threats = Get-MpThreatDetection -ErrorAction SilentlyContinue | Where-Object { 
              $_.Resources -like "*$($file.Name)*" 
            }
            
            if ($threats) {
              Write-Host "::error::Threat detected in $($file.Name)"
              $threats | ForEach-Object {
                Write-Host "  Threat: $($_.ThreatName)"
                Write-Host "  Severity: $($_.InitialSeverity)"
              }
              $hasThreats = $true
              $scanResults += "‚ùå $($file.Name): Threats detected"
            } else {
              Write-Host "‚úì $($file.Name): Clean"
              $scanResults += "‚úì $($file.Name): Clean"
            }
          } catch {
            Write-Host "::warning::Could not scan $($file.Name): $($_.Exception.Message)"
            $scanResults += "‚ö† $($file.Name): Scan skipped"
          }
        }
        
        Write-Host "`n=== Scan Summary ==="
        $scanResults | ForEach-Object { Write-Host $_ }
        
        if ($hasThreats) {
          Write-Host "::error::Virus scan failed - threats detected!"
          exit 1
        } else {
          Write-Host "‚úì All files passed virus scan"
        }

    # ============================================
    # Release (only on main branch)
    # ============================================
    - name: Get version from project
      id: get_version
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        $version = (Select-String -Path "src/ClaudeCodeInstaller.Core/ClaudeCodeInstaller.Core.csproj" -Pattern '<Version>([^<]+)</Version>').Matches.Groups[1].Value
        $rcTag = "v$version-rc.$(Get-Date -Format 'yyyyMMddHHmmss')"
        Write-Host "Version: $version"
        Write-Host "RC Tag: $rcTag"
        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "tag=$rcTag" >> $env:GITHUB_OUTPUT

    - name: Get previous tag
      id: previous_tag
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        $previousTag = git describe --tags --abbrev=0 HEAD^ 2>$null
        if ($LASTEXITCODE -ne 0) {
          $previousTag = ""
        }
        Write-Host "Previous tag: $previousTag"
        echo "tag=$previousTag" >> $env:GITHUB_OUTPUT

    - name: Generate changelog
      id: changelog
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        $previousTag = "${{ steps.previous_tag.outputs.tag }}"
        $currentTag = "${{ steps.get_version.outputs.tag }}"
        
        if ($previousTag -eq "") {
          Write-Host "No previous tag found, getting all commits"
          $commits = git log --pretty=format:"%s" HEAD
        } else {
          Write-Host "Getting commits since $previousTag"
          $commits = git log --pretty=format:"%s" ${previousTag}..HEAD
        }
        
        $changelog = "## Changelog`n`n"
        
        # Categorize commits by type
        $features = @()
        $fixes = @()
        $docs = @()
        $refactor = @()
        $other = @()
        
        foreach ($commit in $commits) {
          if ($commit -match '^feat(\(.+\))?: (.+)') {
            $features += "- $($matches[2])"
          } elseif ($commit -match '^fix(\(.+\))?: (.+)') {
            $fixes += "- $($matches[2])"
          } elseif ($commit -match '^docs(\(.+\))?: (.+)') {
            $docs += "- $($matches[2])"
          } elseif ($commit -match '^refactor(\(.+\))?: (.+)') {
            $refactor += "- $($matches[2])"
          } elseif ($commit -notmatch '^(chore|ci|build|test|style)') {
            $other += "- $commit"
          }
        }
        
        if ($features.Count -gt 0) {
          $changelog += "### ‚ú® Features`n"
          $changelog += ($features -join "`n") + "`n`n"
        }
        
        if ($fixes.Count -gt 0) {
          $changelog += "### üêõ Bug Fixes`n"
          $changelog += ($fixes -join "`n") + "`n`n"
        }
        
        if ($refactor.Count -gt 0) {
          $changelog += "### ‚ôªÔ∏è Refactoring`n"
          $changelog += ($refactor -join "`n") + "`n`n"
        }
        
        if ($docs.Count -gt 0) {
          $changelog += "### üìù Documentation`n"
          $changelog += ($docs -join "`n") + "`n`n"
        }
        
        if ($other.Count -gt 0) {
          $changelog += "### üì¶ Other Changes`n"
          $changelog += ($other -join "`n") + "`n`n"
        }
        
        if ($features.Count -eq 0 -and $fixes.Count -eq 0 -and $docs.Count -eq 0 -and $refactor.Count -eq 0 -and $other.Count -eq 0) {
          $changelog += "No significant changes since last release.`n`n"
        }
        
        $changelog += "---`n"
        $changelog += "**Full Changelog**: $previousTag...$currentTag"
        
        Write-Host "Generated changelog:"
        Write-Host $changelog
        echo "changelog<<EOF" >> $env:GITHUB_OUTPUT
        echo $changelog >> $env:GITHUB_OUTPUT
        echo "EOF" >> $env:GITHUB_OUTPUT

    - name: Create RC tag
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        $tag = "${{ steps.get_version.outputs.tag }}"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "$tag" -m "Release Candidate: $tag"
        git push origin "$tag"
        Write-Host "Created tag: $tag"

    - name: Create GitHub Release
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.get_version.outputs.tag }}
        name: Release Candidate ${{ steps.get_version.outputs.tag }}
        body: |
          ${{ steps.changelog.outputs.changelog }}
          
          ## Downloads
          - **WinForms Installer**: ClaudeCodeInstaller.WinForms.exe
        files: |
          artifacts/**/*.exe
        draft: false
        prerelease: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
